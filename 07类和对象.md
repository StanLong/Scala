# 类和对象

```scala
package com.stanlong.scala

/**
 * 类和对象
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val cat = new Cat() // 括号可以省略
        cat.name = "小白猫"
        cat.age = 10
        cat.color = "白色"
        println("ok~")
        printf("\n小猫的信息如下: %s %d %s", cat.name, cat.age, cat.color)
    }
}
class Cat{
    var name:String=""
    var age:Int= 0
    var color = ""
}
```

## 类反编译文件

Cat.class

```java
package com.stanlong.scala;

import scala.reflect.ScalaSignature;

@ScalaSignature
public class Cat
{
  private String name = "";
  private int age = 0;
  private String color = "";

  public String name()
  {
    return this.name; } 
  public void name_$eq(String x$1) { this.name = x$1; } 
  public int age() { return this.age; } 
  public void age_$eq(int x$1) { this.age = x$1; } 
  public String color() { return this.color; } 
  public void color_$eq(String x$1) { this.color = x$1; }

}
```

Exercise01$.class

```java
package com.stanlong.scala;

import scala.Predef.;
import scala.runtime.BoxesRunTime;
import scala.runtime.ScalaRunTime.;

public final class Exercise01$
{
  public static final  MODULE$ = new ();

  public void main(String[] args) { Cat cat = new Cat();
    cat.name_$eq("小白猫");
    cat.age_$eq(10);
    cat.color_$eq("白色");
    Predef..MODULE$.println("ok~");
    Predef..MODULE$.printf("\n小猫的信息如下: %s %d %s", ScalaRunTime..MODULE$.genericWrapArray(new Object[] { cat.name(), BoxesRunTime.boxToInteger(cat.age()), cat.color() }));
  }
}
```

## 说明

```
1. 一个class Cat对应的字节码文件只有一个 Cat.class,默认修饰符public

2.当我们声明 var name:String时，在底层对应的是 private name。同时生成public方法 name() <=类似=> getter 方法. public name_$eq()<=类似=> setter方法

3.cat.name = "小白猫", 其实访问的不是属性，而是 cat.name_$eq("小白猫")

4.Scala中声明一个属性,必须显示的初始化，然后根据初始化数据的类型自动推断，属性类型可以省略

5.如果在定义属性时，暂时不赋值，也可以使用符号_(下划线)，让系统分配默认值.
Byte Short Int Long 默认值 0
Float Double        默认值 0.0
String 和 引用类型    默认值 null
Boolean             默认值 false
```

# scala创建对象流程

```scala
class Person {
    var age: Short = 90
    var name: String
    = _
    def this (n: String, a: Int) {
        this ()
        this.name = n
        this.age = a
    }
}

var p: Person = new Person ("小倩", 20)

--------------------------------------------------------------------------

流程分析(面试题-写出)
加载类的信息(属性信息，方法信息)
在内存中(堆)开辟空间
使用父类的构造器(主和辅助)进行初始
使用主构造器对属性进行初始化 【age:90, naem nul】
使用辅助构造器对属性进行初始化 【 age:20, naem 小倩 】
将开辟的对象的地址赋给 p这个引用
```

# 类实例操作

```scala
package com.stanlong.scala

/**
 * 抽象类
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val bank = new Bank("StanLong", 100.00, "123456")
        //bank.query("StanLong", "123456")
        //bank.withdraw("StanLong", "123456", 10.00)
        bank.save("StanLong", "123456", 10.00)

    }
}

/**
 * 属性：账号，余额，密码
 * 方法：查询，存款，取款
 */
class Bank(inAccount:String, inBalance:Double, inPwd:String){
    val accountNo = inAccount
    val balance = inBalance
    var pwd = inPwd

    // 查询
    def query(accountNo:String, pwd:String):Unit={
        if(!this.accountNo.equals(accountNo) && !this.pwd.equals(pwd)){
            println("用户名或密码错误！")
            return
        }
        printf("账号为 %s 当前余额是%.2f\n", this.accountNo, this.balance)
    }

    // 取钱
    def withdraw(accountNo:String, pwd:String, balance:Double): Unit ={
        if(balance > this.balance){
            println("余额补足")
        }else{
            printf("%s 取出金额 %.2f， 剩余金额%.2f", this.accountNo, this.balance, (this.balance-balance))
        }
    }

    // 存钱
    def save(accountNo:String, pwd:String, balance:Double): Unit ={
        printf("%s 取出金额 %.2f， 剩余金额%.2f", this.accountNo, this.balance, (this.balance+balance))
    }
}
```

# 抽象类

1. 抽象类不能被实例化

   ```scala
   package com.stanlong.scala
   
   /**
    * 抽象类不能被实例
    */
   object Exercise01 {
       def main(args: Array[String]): Unit = {
           println("ok100")
           //下面代码错误，抽象类不能实例化
           // val obj = new Animal()
       }
   }
   
   abstract class Animal{
       var name : String //抽象的字段
       var age : Int // 抽象的字段
       var color : String = "black"
       //我们发现这个父类的方法，被子类继承后，没有什么用处，但是我们还
       //希望子类将来必须有这个cry方法,但是目前cry 不用写，声明为抽象的方法
       def cry()
   }
   ```

2. 抽象类不一定要包含abstract方法。也就是说,抽象类可以没有abstract方法。

3. 一旦类包含了抽象方法或者抽象属性,则这个类必须声明为abstract

4. 抽象方法不能有主体，不允许使用abstract修饰。

5. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法和抽象属性，除非它自己也声明为abstract类。

   ```scala
   package com.stanlong.scala
   
   /**
    * 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法和抽象属性，除非它自己也声明为abstract类
    */
   object Exercise01 {
       def main(args: Array[String]): Unit = {
           println("ok100")
   
       }
   }
   
   abstract class Animal{
       var name : String //抽象的字段
       var age : Int // 抽象的字段
       var color : String = "black"
       //我们发现这个父类的方法，被子类继承后，没有什么用处，但是我们还
       //希望子类将来必须有这个cry方法,但是目前cry 不用写，声明为抽象的方法
       def cry()
   }
   
   class Dog extends Animal{
       var name : String = _
       var age : Int = _
       def cry(): Unit = {
           println("小狗汪汪叫唤..")
       }
   }
   ```

6. 抽象方法和抽象属性不能使用private、final 来修饰，因为这些关键字都是和重写/实现相违背的。

7. 抽象类中可以有实现的方法.

8. 子类重写抽象方法不需要override，写上也不会错

# 匿名子类

```scala
package com.stanlong.scala

/**
 * 匿名子类
 * 通过包含带有定义或重写的代码块的方式创建一个匿名的子类
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {

        //这里就是就创建了一个抽象类Monster 的匿名子类实例 monster
        //机制和java的匿名子类一样.
        var monster = new Monster {

            override var name: String = "牛魔王"
            override def cry(): Unit = {
                println("牛魔王哼哼叫唤..")
            }
        }

        monster.cry()
    }
}

abstract class Monster{
    var name : String
    def cry()
}
```



