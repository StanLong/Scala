# 高阶函数



## scan

```scala
package com.stanlong.scala

/**
 * 扫描
 * 扫描，即对某个集合的所有元素做fold操作，但是会把产生的所有中间结果放置于一个集合中保存
 * scan 默认等于 scanleft
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {

        // 执行步骤
        // 5
        // 5-1 = 4
        // 5-1-2 = 2
        // 5-1-2-3 = -1
        // 5-1-2-3-4 = -5
        // 5-1-2-3-4-5 = -10
        val i7 = (1 to 5).scan(5)(minus) //IndexedSeq[Int]
        println(i7)
        // Vector(5, 4, 2, -1, -5, -10)

        val i8 = (1 to 5).scanLeft(5)(minus) //IndexedSeq[Int]
        println(i8)
        // Vector(5, 4, 2, -1, -5, -10)

        // 执行步骤, 从右边开始看
        // 5
        // 5-5 = 0
        // 4-(5-5) = 4
        // 3-(4-(5-5)) = -1
        // 2-(3-(4-(5-5))) = 3
        // 1-(2-(3-(4-(5-5)))) = -2
        val i6 = (1 to 5).scanRight(5)(minus) //IndexedSeq[Int]
        println(i6)
        // Vector(-2, 3, -1, 4, 0, 5)

        // 执行步骤
        //5
        //5+1 = 6
        //5+1+2 = 8
        //5+1+2+3 = 11
        //5+1+2+3+4 = 15
        //5+1+2+3+4+5 = 20
        val i9 = (1 to 5).scanLeft(5)(add) //IndexedSeq[Int]
        println(i9)
        // Vector(5, 6, 8, 11, 15, 20)
    }
    def minus( num1 : Int, num2 : Int ) : Int = {
        num1 - num2
    }

    def add( num1 : Int, num2 : Int ) : Int = {
        num1 + num2
    }
}
```



## 迭代器

```scala
package com.stanlong.scala

/**
 * 迭代器
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val iterator = List(1, 2, 3, 4, 5).iterator // 得到迭代器
        println("--------遍历方式1 -----------------")
        while (iterator.hasNext) {
            println(iterator.next())
        }
        println("--------遍历方式2 for -----------------")
        for(enum <- iterator) {
            println(enum)
        }

    }
}
```

## 流

```scala
package com.stanlong.scala

/**
 * 流 Stream
 * stream是一个集合。这个集合，可以用于存放无穷多个元素，但是这无穷个元素并不会一次性生产出来，而是需要用到多大的区间，就会动态的生产，
 * 末尾元素遵循lazy规则(即：要使用结果才进行计算的)
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        //创建Stream
        def numsForm(n: BigInt) : Stream[BigInt] = n #:: numsForm(n + 1)
        val stream1 = numsForm(1)
        println(stream1)

        //再测试一个
        val stream2 = numsForm(10)
        println(stream2)


        //head和tail
        println("head=" + stream1.head) //1
        println(stream1.tail) //Stream(2, ?)

        println(stream1) //Stream(1, 2, ?)
        println(stream1.tail.tail) //Stream(3, ?)
        println(stream1) //Stream(1, 2, 3, ?)

        // 使用map映射stream的元素并行进行计算
        def multi(x:BigInt) : BigInt = {
            x * x
        }
        println(numsForm(5).map(multi)) //? (25,?)
    }
}
```

## 视图view

```scala
package com.stanlong.scala

/**
 * 视图
 * Stream的懒加载特性，也可以对其他集合应用view方法来得到类似的效果，具有如下特点：
 * view方法产出一个总是被懒执行的集合。
 * view不会缓存数据，每次都要重新计算，比如遍历View时
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        def multiple(num: Int): Int = {
            num
        }

        def eq(i: Int): Boolean = {
            //如果i这个数字倒序后，和本身相同，则返回true
            i.toString.equals(i.toString.reverse)
        }

        //说明: 没有使用view
        //1. 对 1-100 进行遍历
        //2. map(multiple) 对 1-100进行map映射操作，这里其实就是简单的复制一份
        //3. filter(eq) 使用eq方法对新的集合进行过滤，条件为i.toString.equals(i.toString.reverse)
        val viewSquares1 = (1 to 100).map(multiple).filter(eq)

        println(viewSquares1)
        for (x <- viewSquares1) {
            print(x + "，")
        }

        println("\n-----------------------------")
        //使用view
        //1. 使用和前面一样，只是使用了view
        //2. view方法产出一个总是被懒执行的集合
        //3. view不会缓存数据，每次都要重新计算
        val viewSquares2 = (1 to 100).view.map(multiple).filter(eq)

        println(viewSquares2)
        for (x <- viewSquares2) {
            print(x + "，")
        }
    }
}
```

