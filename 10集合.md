# 集合

- 不可变集合：就是指该集合对象不可修改，每次修改就会返回一个新对象，而不会对原对象进行修改。类似于 Java 中的 String 对象
- 可变集合：就是这个集合可以直接对原对象进行修改，而不会返回新的对象。类似于 Java 中的 StringBuilder对象

**建议：** 在操作集合的时候，不可变用符号，可变用方法

不可变集合关系继承图：蓝色表示具体的类型，另一种颜色表示特征

![](./doc/33-1.png)

不可变集合关系继承图：蓝色表示具体的类型，另一种颜色表示特征

![](./doc/34.png)

## 不可变数组

```scala
package com.stanlong.scala

/**
 * 不可变数组
 */
object HelloScala {

    def main(args: Array[String]): Unit = {
        // 第一种方式，使用默认值
        val arr01 = new Array[Int](4) // [Int]表示该数组只能放Int， [Any] 表示可以存任何类型
        // 第二种方式：指定初始值
        val arr02 = Array(1, 2, "xxx")

        // 通过下标修改数组
        arr02(2) = 3
        println(arr02(2))

        // 添加元素(在列表最后添加) :+
        val arr03 = arr02.:+(4) // 或者写成 val arr03 = arr02 :+ 4
        println(arr03.mkString(","))  // 1,2,3,4

        // 添加元素(在列表前面添加) +:
        val arr04 = arr02.+:(0) // 或者写成 val arr04 = 0 +: arr02 注意顺序
        println(arr04.mkString(",")) // 0,1,2,3

        // 获取数组长度
        println(arr01.length)

        // 遍历数组的集中方式

        // 1. 直接遍历(增强for循环)
        for (i <- arr02) {
            println(i)
        }

        // 2. 使用下标遍历数组
        for (index <- 0 until arr02.length){
            printf("arr02[%d]=%s ", index, arr02(index) + "\t")
        }

        // 3. 方式2 的简写
        for( i <- arr02.indices){
            println(arr02(i))
        }

        // 4. 使用迭代器
        val iter = arr02.iterator
        while (iter.hasNext){
            println(iter.next())
        }

        // 5. foreach 方法
        arr01.foreach((elem: Int) => println(elem))
        // 简写
        arr01.foreach(println)

    }
}
```

## 可变数组

```scala
package com.stanlong.scala

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer


/**
 * 可变数组
 */
object HelloScala {

    def main(args: Array[String]): Unit = {
        // 创建可变数组
        val arr01 = ArrayBuffer[Int]()
        val arr02 = ArrayBuffer(1,2,3,4)
        println(arr02) // ArrayBuffer(1, 2, 3, 4) 底层调用的是 arr02.toString()

        // 添加元素(在后面添加)
        arr01.append(5) // 或者 arr01 += 5
        println(arr01)

        // 添加元素(在前面添加)
        arr01.prepend(0) // 或者 0 +=: arr01
        println(arr01)

        // 指定索引位置添加
        arr01.insert(1,2,3,4,5)
        println(arr01)

        // 追加数组
        arr01.insertAll(2, arr02) // 同样有 appendAll 和 prependAll
        println(arr01)


        //删除
        arr01.remove(0) // 删除索引 0 位置的元素
        println(arr01)
        arr01.remove(1, 4) // 从索引1开始，往后删除4个, 包含索引1的元素
        println(arr01)
        arr01 -= 5 // 直接删除元素值， 有就删除， 有重复的话只会删掉一个
        println(arr01)

        // 可变数组转换为不可变数组
        val arr03 = arr01.toArray
        println(arr03.mkString(","))
        println(arr01)

        // 不可变数组转换为可变数组
        val buffer: mutable.Buffer[Int]  arr03.toBuffer
        println(buffer)
    }
}
```

## 多维数组

```scala
package com.stanlong.scala

/**
 * 多维数组
 */
object HelloScala {

    def main(args: Array[String]): Unit = {
        // 创建二维数组
        val array1 = Array.ofDim[Int](3, 4)

        // 访问元素
        println(array1(0)(1))

        // 修改元素
        array1(1)(1) = 9

        // 遍历多维数组
        // 方式一 : 增强for循环
        for (item <- array1) {
            for (item2 <- item) {
                print(item2 + "\t")
            }
            println()
        }
        println("===================")

        // 方式二: 使用下标遍历多维数组
        for (i <- 0 to array1.length - 1) {
            for (j <- 0 to array1(i).length - 1) {
                printf("arr[%d][%d]=%d\t", i, j, array1(i)(j))
            }
            println()
        }

        // 方式二简写
        for (i <- array1.indices; j <- array1(i).indices){
            // println(array1(i)(j))
            print(array1(i)(j) + "\t")
            if(j == array1(i).length -1){
                println()
            }
        }

        // 方式三： foreach
        array1.foreach(line => line.foreach(println))
        // 简写
        array1.foreach(_.foreach(println))
    }
}
```

## 列表List

```scala
package com.stanlong.scala

/**
 * 不可变列表
 * 在scala中List默认为不可变的集合
 */
object HelloScala {

    def main(args: Array[String]): Unit = {

        //创建List
        val list01 = List(1, 2, 3)

        // 访问
        println(list01)
        println(list01(1))

        // 遍历
        list01.foreach(println)

        // 追加元素
        // 方式一
        // 在列表后追加元素
        val list03 = list01 :+ 4
        println(list03)

        // 在列表前追加元素 注意顺序
        val list04 = 4 +: list01
        println(list04)

        // 方式二 ::
        // 往空列表里追加元素
        // 运算时，集合对象一定要放置在最右边
        // 运算规则，从右向左
        val list06 = 1 :: 2 :: 3 :: 4 :: Nil
        println(list06)

        // 合并列表
        // 方式一  ::: 运算符, ::: 两边都必须是集合元素
        val list07 = 1 :: 2 :: 3 :: list01 :::Nil
        println(list07)

        // 方式二  ++ 运算符
        val list08 = list01 ++ list07
        println(list08)
    }
}
```

```scala
package com.stanlong.scala

import scala.collection.mutable.ListBuffer

/**
 * 可变列表
 */
object HelloScala {

    def main(args: Array[String]): Unit = {
        // 创建可变列表
        val list0 = ListBuffer[Int](1, 2, 3)
        val list1 = ListBuffer(12,23,45)

        println(list0)
        println(list1)

        // 添加元素
        list0.append(5) // 在后面添加
        list0.prepend(0) // 在前面添加
        list0.insert(2,300) // 指定位置添加

        // 合并列表
        val list2 = list0 ++ list1
        println(list0) // 不变
        println(list1) // 不变
        println(list2) // 合并

        list0 ++= list1 // 如果是 ++=: 那结果就是 list0 不变, list1 合并
        println(list1) // 不变
        println(list0) // 合并

        // 修改元素
        list1(0) = 0
        list1.update(2, 20)
        println(list1)

        // 删除
        list1.remove(1)
        list1 -= 45
        println(list1)
    }
}
```

## Set集合

```scala
package com.stanlong.scala

import scala.collection.mutable

/**
 * Set:集
 * 集是不重复元素的结合
 * 默认情况下，Scala 使用的是不可变集合
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 创建
        val set01 = Set(1,2,4,"abc") // 不可变
        println(set01) // Set(1, 2, 4, abc)
        val set02 = mutable.Set(1,2,4,"abc") // 可变
        println(set02) // HashSet(1, 2, abc, 4)

        // 新增
        // 如果添加的对象已经存在，则不会重复添加，也不会报错
        set02.add(90)
        set02 += 78
        set02 += 90
        println(set02)

        // 删除
        set02 -= 2 // 操作符形式
        set02.remove("abc") // 方法的形式，scala的Set可以直接删除值
        println(set02)

        // 遍历
        for(x <- set02) {
            println(x)
        }
    }
}
```

## 元组

```scala
package com.stanlong.scala

/**
 * 元组
 * 元组也是可以理解为一个容器，可以存放各种相同或不同类型的数据
 * 元组中最大只能有22个元素
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 元组的创建
        val tuple1 = (1, 2, 3, "hello", 4)
        println(tuple1)

        // 元组的访问
        val t1 = (1, "a", "b", true, 2)
        println(t1._1) //访问元组的第一个元素 ，从1开始
        println(t1.productElement(0)) // 访问元组的第一个元素，从0开始

        // 元组的遍历
        // 元组的遍历需要调其迭代器
        for ( item <- t1.productIterator ) {
            println(item)
        }
    }
}
// 元组排序，先排第一个，再排第二个，再排第三个，依次排序
```

## 队列

```scala
package com.stanlong.scala

import scala.collection.mutable


/**
 * Queue
 * 队列是一个有序列表，在底层可以用数组或是链表来实现
 * 其输入和输出要遵循先入先出的原
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {

        // 创建队列
        val q = new mutable.Queue[Int]()
        println(q)

        // 往队列里新增元素
        q += 9
        println(q)
        q ++= List(1,2,3)
        println(q)

        val q1 = new mutable.Queue[Int]
        q1 += 12
        q1 += 34
        q1 ++= List(2,9)
        q1.dequeue() //从队列头部取出元素
        println(q1)
        q1.enqueue(20,60) //在队列尾部添加元素
        println(q1)

        // 返回队列的元素
        println(q1.head) // 返回队列的第一个元素
        println(q1.last) // 返回队列最后一个元素
        println(q1.tail) // 返回除了第一个以外剩余的元素， 可以级联使用，这个在递归时使用较多
        println(q1.tail.tail)


        //补充操作符重载...
        val cat = new Cat
        println(cat.age)
        cat += 9
        println(cat.age)
    }
}

class Cat {
    var age: Int = 10
    def +=(n:Int): Unit = {
        this.age += n
        println("xxx")
    }
}
```

## Map集合

```scala
package com.stanlong.scala

import scala.collection.mutable

/**
 * Map
 * Scala中，有可变Map (scala.collection.mutable.Map) 和 不可变Map(scala.collection.immutable.Map)
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 创建
        val map1 = Map("Alice" -> 10, "Bob" -> 20, "Kotlin" -> "北京") // 不可变, 输出顺序和声明顺序一致
        println(map1)

        val map2 = scala.collection.mutable.Map("Alice" -> 10, "Bob" -> 20, "Kotlin" -> 30) // 可变, 输出顺序和声明顺序不一致
        println(map2)

        // 创建空映射
        val map3 = new scala.collection.mutable.HashMap[String, Int]
        println(map3)

        // 对偶元组
        //即创建包含键值对的二元组， 和第一种方式等价，只是形式上不同而已。
        //对偶元组 就是只含有两个数据的元组。
        val map4 = mutable.Map( ("A", 1), ("B", 2), ("C", 3),("D", 30) )
        println("map4=" + map4)
        println(map4("A"))

        // 遍历
        // 如果key存在，则返回对应的值
        // 如果key不存在，则抛出异常[java.util.NoSuchElementException]
        // 在Java中,如果key不存在则返回null
        val value1 = map2("Alice")
        println(value1)

        // 使用contains方法检查是否存在key
        // 返回Boolean
        // 1.如果key存在，则返回true
        // 2.如果key不存在，则返回false
        if( map4.contains("B") ) {
            println("key存在 值= " + map4("B"))
        } else {
            println("key不存在")
        }

        // 使用map.get(key).get取值
        // map.get方法会将数据进行包装
        // 如果 map.get(key) key存在返回some,如果key不存在，则返回None
        // 如果 map.get(key).get  key存在，返回key对应的值,否则，抛出异常 java.util.NoSuchElementException: None.get
        println(map4.get("A")) //Some
        println(map4.get("A").get) //得到Some在取出

        // 使用map4.getOrElse()取值
        // getOrElse 方法 : def getOrElse[V1 >: V](key: K, default: => V1)
        //说明：
        //如果key存在，返回key对应的值。
        //如果key不存在，返回默认值。在java中底层有很多类似的操作
        println(map4.getOrElse("A","默认"))

        // 修改， 删除
        val map5 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
        map5("AA") = 20
        println(map5)

        // 增加单个元素
        val map6 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
        map6 += ( "D" -> 4 )
        map6 += ( "B" -> 50 )
        println(map6)

        // 增加多个元素
        val map7 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
        val map8 = map7 + ("E"->1, "F"->3)
        map7 += ("EE"->1, "FF"->3)
        println(map7)
        println(map8)

        // 删除元素
        val map9 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
        map9 -= ("A", "B")
        println("map9=" + map9)

        // 遍历
        val map10 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
        for ((k, v) <- map10){
            println(k + " is mapped to " + v)
        }
        for (v <- map10.keys) {
            println(v)
        }
        for (v <- map10.values) {
            println(v)
        }
        for(v <- map10) {
            println(v)
        }
    }
}
```





