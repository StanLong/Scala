# 模式匹配

## match

```scala
package com.stanlong.scala

/**
 * 模式匹配 -- match
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 模式匹配，类似于Java的switch语法

        // 说明
        // 如果所有case都不匹配，那么会执行case _ 分支，类似于Java中default语句
        //如果所有case都不匹配，又没有写case _ 分支，那么会抛出MatchError
        //每个case中，不用break语句，自动中断case
        //可以在match中使用其它类型，而不仅仅是字符
        // => 等价于 java swtich 的 :
        // => 后面的代码块到下一个 case， 是作为一个整体执行，可以使用{} 扩起来，也可以不扩。


        val oper = '+'
        val n1 = 20
        val n2 = 10
        var res = 0
        oper match {
            case '+' => res = n1 + n2
            case '-' => res = n1 - n2
            case '*' => res = n1 * n2
            case '/' => res = n1 / n2
            case _ => println("oper error")
        }
        println("res=" + res)

    }

}
```

## 守卫

```scala
package com.stanlong.scala

/**
 * 模式匹配 -- 守卫
 * 如果想要表达匹配某个范围的数据，就需要在模式匹配中增加条件守卫
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        for (ch <- "+-3!") {
            var sign = 0
            var digit = 0
            ch match {
                case '+' => sign = 1
                case '-' => sign = -1
                // 说明..
                case _ if ch.toString.equals("3") => digit = 3
                case _ => sign = 2
            }
            println(ch + " " + sign + " " + digit)
        }
    }

}
```

## 模式中的变量

```scala
package com.stanlong.scala

/**
 * 模式中的变量
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val ch = 'V'
        ch match {
            case '+' => println("ok~")
            // case mychar 含义是 mychar = ch
            case mychar => println("ok~" + mychar)
            case _ => println ("ok~~")
        }
    }
}
```

