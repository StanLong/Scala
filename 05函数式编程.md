# 函数式编程

![](./doc/14.png)

```scala
package com.stanlong.scala

import scala.util.control.Breaks.{break, breakable}

/**
 * 函数和方法
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 方法
        val operator = new Operator
        println(operator.add_operator(10,20))

        // 方法转函数
        val f1 = operator.add_operator _ // 注意这有个下划线
        println("f1=" + f1)
        // f1=com.stanlong.scala.Exercise01$$$Lambda$3/1205044462@22a71081
        println("f1=" + f1(10,20))
        // f1=30

        // 函数
        val f2 = (n1:Int, n2:Int) =>{
            n1 + n2
        }
        println("f2=" + f2)
        // f2=com.stanlong.scala.Exercise01$$$Lambda$4/1654589030@1bc6a36e
        println("f2=" + f2(10,20))
        // f2=30

    }
}

class Operator{
    def add_operator(n1:Int, n2:Int):Int={
        n1 + n2
    }
}
```

```
基本语法
def 函数名 ([参数名: 参数类型], ...)[[: 返回值类型] =] {
	语句...
	return 返回值
}
函数声明关键字为def  (definition)
[参数名: 参数类型], ...：表示函数的输入(就是参数列表), 可以没有。 如果有，多个参数使用逗号间隔
函数中的语句：表示为了实现某一功能代码块
函数可以有返回值,也可以没有
返回值形式1:    : 返回值类型  =   
返回值形式2:    =  表示返回值类型不确定，使用类型推导完成
返回值形式3:      表示没有返回值，return 不生效
如果没有return ,默认以执行到最后一行的结果作为返回值
```

递归

```scala
package com.stanlong.scala

/**
 * 递归
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        println(fbn(5))

    }
    // 斐波那契数列
    def fbn(n:Int):Int={
        if( n == 1 || n == 2){
            return 1
        }else{
            return fbn(n-1) + fbn(n-2)
        }

    }
}
```

可变形参

```scala
package com.stanlong.scala

/**
 * 可变形参
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        var result = sum(10, 20, 30, 40)
        println(result)

    }
    // args:Int* 可变形参，可变形参得是最后一个参数
    def sum(num1:Int, args:Int*):Int ={
        var sum = num1;
        for(item <- args){
            sum = sum + item
        }
        sum // scala 语言可以省略return
    }
}
```

## 惰性函数

```scala
package com.stanlong.scala

/**
 * 惰性函数
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        lazy val result = sum(10,20) // 这段使用了lazy， 函数中的println("测试懒加载")并不会执行
        println("----------------")
        println("result = " + result) // 只有在函数调用的时候， 函数中的println("测试懒加载")才会执行
    }
    // args:Int* 可变形参，可变形参得是最后一个参数
    def sum(num1:Int, args:Int*):Int ={
        println("测试懒加载")
        var sum = num1;
        for(item <- args){
            sum = sum + item
        }
        sum
    }
}
```

## 高阶函数

```scala
package com.stanlong.scala

/**
 * 高阶函数
 * 能够接受函数作为参数的函数，叫做高阶函数
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 案例一
        val result = test(sum2, 3.5)
        println(result)

        // 案例二
        // 在scala中，可以把一个函数直接赋值给一个变量，但是不执行函数，使用下面这种写法
        val f1 = myPrint _
        f1() // 执行

        // 案例三
        test2(sayOK)

        // 案例四
        val res = test4(sum, mod, 5.0)
        println(res)

        // 案例五
        // 高阶函数可以返回函数类型
        // 1. 分步执行
        val f2 = minusxy(3) // 匿名函数f2 = 3-y
        println(f2(1))  // 3-1
        println(f2(9))  // 3-9
        
        // 2. 一步到位执行
        val result3 = minusxy(3)(5) // 返回的匿名函数可以用变量接受
        println(result3)

    }

    // 案例一
    // test是一个高阶函数
    // f:Double=>Double 表示一个函数，该函数可以接受一个Double， 返回double
    // n1:Double 普通参数
    // f(n1) 执行传入的函数
    def test(f:Double=>Double, n1:Double)={
        f(n1)
    }

    def sum2(d:Double):Double={
        d + d
    }

    // 案例二
    def myPrint(): Unit ={
        println("Hello World")
    }

    // 案例三
    // 说明test2是一个高阶函数，可以接受一个没有输入，返回哦Unit的函数
    def test2(f: () => Unit) = {
        f()
    }
    def sayOK() = {
        println("sayOKKK...")
    }

    def test4(f:Double=>Double, f2:Double=>Int, n1:Double) ={
        f(f2(n1))
    }

    def sum(d:Double):Double ={
        d + d
    }
    def mod(d:Double):Int={
        d.toInt % 2
    }

    // minusxy(3)执行minusxy(x: Int)得到 (y: Int) => 3 - y 这个匿名函
    //minusxy(3)(5)执行 (y: Int) => x - y 这个匿名函数
    //也可以分步执行: val f1 = minusxy(3);   val res = f1(9)
    def minusxy(x: Int) = {
        (y: Int) => x - y // 该函数返回一个匿名函数
    }

}
```

## 高级编程

### 偏函数

```scala
package com.stanlong.scala

/**
 * 偏函数
 * 将包在大括号内的一组case语句封装为函数，我们称之为偏函数，它只对会作用于指定类型的参数或指定范围值的参数实施计算，
 * 超出范围的值会忽略（未必会忽略，这取决于你打算怎样处理）
 *
 * 入门案例
 * 已知集合val list = List(1, 2, 3, 4, "abc") ，请完成如下要求:
 * 将集合list中的所有数字+1，并返回一个新的集合
 * 要求忽略掉 非数字 的元素，即返回的 新的集合 形式为 (2, 3, 4, 5)
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        val list = List(1, 2, 3, 4, "abc")

        // 思路一 filter + map 方式解决
        println(list.filter(f1).map(f2).map(f3))

        // 思路二，使用偏函数解决
        // PartialFunction[Any, Int] 表示偏函数接受的类型是Any， 返回的类型是Int
        // isDefinedAt 如果返回true， 就会去调用apply构建对象实例。如果是false，则过滤
        // apply 构造器， 对传入的值加一， 并返回新的集合
        val partialFun =  new PartialFunction[Any, Int] {
            override def isDefinedAt(x: Any): Boolean = x.isInstanceOf[Int]

            override def apply(v1: Any): Int = {
                v1.asInstanceOf[Int] + 1
            }
        }
        // 使用偏函数
        println(list.collect(partialFun))

        // 使用构建特质的实现类(使用的方式是PartialFunction的匿名子类)
        // PartialFunction 是个特质(看源码)
        // 构建偏函数时，参数形式   [Any, Int]是泛型，第一个表示参数类型，第二个表示返回参数
        //当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行isDefinedAt()如果为true ,就会执行 apply, 构建一个新的Int 对象返回
        //执行isDefinedAt() 为false 就过滤掉这个元素，即不构建新的Int对象.
        //map函数不支持偏函数，因为map底层的机制就是所有循环遍历，无法过滤处理原来集合的元素
        //collect函数支持偏函数

        // 偏函数简化形式
        // 1.简化形式一
        val list1 = list.collect(f4)
        println(list1)

        // 2.简化形式二
        val list2 = list.collect{ case i: Int => i + 1 }
        println(list2)
    }

    def f1(n:Any):Boolean={
        n.isInstanceOf[Int]
    }
    def f2(n:Any):Int={
        n.asInstanceOf[Int]
    }
    def f3(n:Int):Int={
        n + 1
    }

    def f4: PartialFunction[Any, Int] = {
        case i: Int => i + 1 // case语句可以自动转换为偏函数
    }
}
```

### 作为参数的函数

```scala
package com.stanlong.scala

/**
 * 函数作为参数
 * 函数作为一个变量传入到了另一个函数中，那么该作为参数的函数的类型是：function1，即：(参数类型) => 返回类型
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        //说明
        val result1 = Array(1, 2, 3, 4).map(plus(_))
        println(result1.mkString(","))

        println("plus的函数类型function1" + (plus _))

        // map(plus(_)) 中的plus(_) 就是将plus这个函数当做一个参数传给了map，_这里代表从集合中遍历出来的一个元素。
        //
        //plus(_) 这里也可以写成 plus 表示对 Array(1,2,3,4) 遍历，将每次遍历的元素传给plus的 x
        //进行 3 + x 运算后，返回新的Int ，并加入到新的集合 result1中
        //def map[B, That](f: A => B) 的声明中的 f: A => B 一个函数

    }
    def plus(x: Int) = 3 + x
}
```

### 匿名函数

```scala
package com.stanlong.scala

/**
 * 匿名函数
 * 没有名字的函数就是匿名函数，可以通过函数表达式来设置匿名函数
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        val triple = (x: Double) => 3 * x
        println(triple(3))

        // (x: Double) => 3 * x 就是匿名函数
        //(x: Double) 是形参列表， => 是规定语法表示后面是函数体， 3 * x 就是函数体，如果有多行，可以 {} 换行写.
        //triple 是指向匿名函数的变量。
    }
}
```

```scala
package com.stanlong.scala

/**
 * 匿名函数
 * 请编写一个匿名函数，可以返回2个整数的和，并输出该匿名函数的类型
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        // 匿名函数不需要写返回类型，使用类型推导
        // = 变成 =》
        // 如果有多行，使用{}
        val f1 = (n1: Int, n2: Int ) => {
            println("匿名函数被调用")
            n1 + n2
        }
        println("f1类型=" + f1)
        println(f1(10, 30))
    }
}
```



