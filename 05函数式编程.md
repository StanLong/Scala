# 函数式编程

![](./doc/14.png)

## 方法与函数的转换

```scala
package com.stanlong.scala

import scala.util.control.Breaks.{break, breakable}

/**
 * 函数和方法
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        // 方法
        val operator = new Operator
        println(operator.add_operator(10,20))

        // 方法转函数
        val f1 = operator.add_operator _ // 注意这有个下划线
        val result =  f1(10,20)  // 类似与数学上的 y=f(x)
        println(result)
    }
}

class Operator{
    def add_operator(n1:Int, n2:Int):Int={
        n1 + n2
    }
}
```

## 可变形参

```scala
package com.stanlong.scala

/**
 *  1. 可变参数
 *  2. 如果参数列表中存在多个参数，那么可变参数一般放置在最后
 *  3. 参数默认值，一般将有默认值的参数放置在参数列表的后面
 *  4. 带名参数
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        // 1. 可变参数
        def f1(s:String *): Unit = {
            println(s)
        }
        f1("hello", "scala")
        // 打印结果: WrappedArray(hello, scala)

        // 2. 如果参数列表中存在多个参数，那么可变参数一般放置在最后
        def f2(str1:String, str2:String *): Unit ={
            println("str1: " + str1 + ", str2: " + str2)
        }
        f2("hello", "java", "scala")
        // 打印结果: str1: hello, str2: WrappedArray(java, scala)

        // 3. 参数默认值，一般将有默认值的参数放置在参数列表的后面
        def f3(name:String="StanLong"): Unit ={
            println(name)
        }

        f3() // StanLong
        f3("张三") // 张三

        // 4. 带名参数
        def f4(name:String, age:Int): Unit ={
            println(s"${age}岁的${name}在经商")
        }

        f4(age=25, name = "沈万三")
    }
}
```

## 至简原则

```scala
package com.stanlong.scala

/**
 * 函数至简原则: 能省则省
 * 1. return 可以省略， Scala会使用函数体的最后一行代码作为返回值
 * 2. 如果函数体只有一行代码，可以省略花括号
 * 3. 返回值类型如果能够推断出来，那么可以省略(: 和返回值一起省略)
 * 4. 如果有return， 则不能省略返回值类型，必须指定
 * 5. 如果函数声明了unit，那么即使函数体中使用了return关键字也不起作用
 * 6. Scala 如果期望是无返回值类型，可以省略等号
 * 7. 如果函数无参，但是声明了参数列表，那么调用的时候，小括号可加可不加
 * 8. 如果函数没有参数列表， 那么小括号可以省略，调用时小括号必须省略
 * 9. 如果不关心名称，只关心逻辑处理，那么函数名 (def) 可以省略。 也即匿名函数， lambda表达式
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={

        def f0(name:String):String ={
            return name
        }
        println(f0("f0"))

        // 1. return 可以省略， Scala会使用函数体的最后一行代码作为返回值
        def f1(name:String):String={
            name
        }
        println(f1("f1"))

        // 2. 如果函数体只有一行代码，可以省略花括号
        def f2(name:String): String = name
        println("f2")

        // 3. 返回值类型如果能够推断出来，那么可以省略(: 和返回值一起省略)
        def f3(name:String) = name // 类似于数学上的f(x) = y
        println("f3")

        // 6. Scala 如果期望是无返回值类型，可以省略等号
        def f6(name:String){
            println(name)
        }
        f6("f6")

        // 7. 如果函数无参，但是声明了参数列表，那么调用的时候，小括号可加可不加
        def f7(): Unit ={
            println("f7")
        }
        f7

        // 8. 如果函数没有参数列表， 那么小括号可以省略，调用时小括号必须省略
        def f8:Unit={
            println("f8")
        }
        // f8() 报错
        f8

        // 9. 如果不关心名称，只关心逻辑处理，那么函数名 (def) 可以省略。 也即匿名函数， lambda表达式
        (name: String) => {println(name)}
    }

}
```

## 匿名函数

```scala
package com.stanlong.scala

/**
 * 匿名函数
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        // 匿名表达式的值返回给 fun， fun即函数式变量
        val fun = (name:String) => {println(name)}
        fun("匿名函数")

        // 匿名函数作为参数, 即把数据的操作方法传递给函数
        def f(func: String=>Unit):Unit={
            func("匿名函数作为参数")
        }
        // 调用方式
        f(fun)
        // 或者
        f((name:String) => {println(name)})
    }
}
```

```scala
package com.stanlong.scala

/**
 * 匿名函数简化原则
 * 1. 参数类型可以省略，会根据形参进行自动的推导
 * 2. 类型省略之后，发现只有一个参数，则小括号可以省略； 其他情况：没有参数和参数超过1的永远不能省略小括号
 * 3. 匿名函数如果只有一行，则大括号以可以省略
 * 4. 如果参数只出现一次，则参数省略且后面的参数可以用 _ 代替， => 也可以省略
 * 5. 如果可以推断出当前传入的println是一个函数体，而不是调用语句，可以直接省略 _
 * 6. 匿名函数不需要写函数的返回值
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        // 匿名表达式的值返回给 fun， fun即函数式变量
        val fun = (name:String) => {println(name)}
        fun("匿名函数")

        // 匿名函数作为参数, 即把数据的操作方法传递给函数
        def f(func: String=>Unit):Unit={
            func("匿名函数作为参数")
        }

        // 调用方式
        f(fun)
        // 或者
        f((name:String) => {println(name)})


        // 1. 参数类型可以省略，会根据形参进行自动的推导
        f((name) => {println(name)})

        // 2. 类型省略之后，发现只有一个参数，则小括号可以省略； 其他情况：没有参数和参数超过1的永远不能省略小括号
        f(name => {println(name)})

        // 3. 匿名函数如果只有一行，则大括号以可以省略
        f(name => println(name))

        // 4. 如果参数只出现一次，则参数省略且后面的参数可以用 _ 代替, => 也可以省略
        f(println(_))

        // 5. 如果可以推断出当前传入的println是一个函数体，而不是调用语句，可以直接省略 _
        f(println)
    }
}
```

```scala
package com.stanlong.scala

/**
 * 匿名函数案例
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        // 定义一个二元运算函数，只操作1和2两个数，但是具体运算通过参数传入
        def dealFunOneAndTwo(fun:(Int, Int) => Int):Int={
            fun(1,2)
        }

        val add = (a:Int, b:Int) => a + b
        val minus = (a:Int, b:Int) => a-b

        println(dealFunOneAndTwo(add))
        println(dealFunOneAndTwo(minus))

        // 匿名函数简化
        println(dealFunOneAndTwo(_+_))
        println(dealFunOneAndTwo(_-_))
    }
}
```

## 高阶函数

```scala
package com.stanlong.scala

/**
 * 高阶函数
 * 1. 函数可以作为值传递
 * 2. 函数可以作为参数传递
 * 3. 函数可以作为函数的返回值返回
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={

        def f0(n:Int):Int={
            println("f1调用")
            n + 1
        }
        val result = f0(123)
        println(result)

        // 1. 函数可以作为值传递，有如下两种写法
        val f2 = f0 _ // f0 _ ：表明 f0 是一个函数整体
        val f1:Int => Int = f0 // f1:Int => Int ： 表明 f1 是一个函数类型

        println(f1) // com.stanlong.scala.Exercise01$$$Lambda$5/1289479439@7cf10a6f 函数的引用地址
        println(f1(12))
        println(f2)
        println(f2(13)) // com.stanlong.scala.Exercise01$$$Lambda$6/6738746@7e0babb1 函数的引用地址

        // 2. 函数可以作为参数传递
        def dealEval(op:(Int, Int) => Int, a:Int, b:Int):Int ={
            op(a, b)
        }

        def add(a:Int, b:Int) : Int = {
            a + b
        }

        val result0 = dealEval(add, 12, 13)
        val result1 = dealEval((a, b) => a+b, 12, 13)
        val result2 = dealEval(_+_, 12,13)
        println("result0=" + result0 +" result1=" + result1 + " result2=" + result2)

        // 3. 函数可以作为函数的返回值返回
        def f5(): Int=>Unit ={
            def f6(a:Int):Unit={
                println("f6调用 " + a)
            }
            f6 // 将函数直接返回
        }
        println(f5) // com.stanlong.scala.Exercise01$$$Lambda$10/288665596@d041cf 函数引用地址
        val f6 = f5()
        println(f6) // com.stanlong.scala.Exercise01$$$Lambda$10/288665596@d041cf 函数引用地址
        println(f6(25))
        println(f5()(25))

    }
}
```

```scala
package com.stanlong.scala

/**
 * 高阶函数实例
 * 实例模仿Spark中的map计算
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        val array:Array[Int] = Array(1,2,3,4,5,6)
        
        // 对数组进行处理， 将操作逻辑抽象出来
        def arrayOperation(array:Array[Int], op:Int=>Int):Array[Int] = {
            for(elem <- array) yield  op(elem)
        }

        def addOne(elem:Int) :Int={
            elem + 1
        }

        val newArray = arrayOperation(array, addOne)
        println(newArray.mkString(","))

    }
}
```

## 闭包

```scala
package com.stanlong.scala

/**
 * 闭包
 * 概念 : 如果一个函数访问到了它的外部(局部)变量的值，那么这个函数和它所处的环境，称为闭包
 * 作用 : 延长外部变量的生命周期，使得内层函数仍可以调用。
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={

        def add(a:Int, b: Int):Int = {
            a + b
        }

        // 1. 考虑固定一个加数的场景
        def addByFour(b:Int):Int={
            4 + b
        }

        // 2. 当固定加数改变时，扩展将固定加数作为参数传入，但是是作为"第一层参数"传入
        def addByA(a:Int): Int => Int = {
            def addB(b:Int):Int = {
                a + b  // 闭包
            }
            addB
        }

        println(addByA(3)(4))

        // addByA 简写
        def addByA1(a:Int) : Int => Int = a + _
    }
}
```

## 柯里化

```scala
package com.stanlong.scala

/**
 * 柯里化
 * 把一个参数列表的多个参数，变成多个参数列表
 * 即把 fun(1,2,3,4)  变成 fun(1)(2)(3)(4)
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        def add(a:Int, b: Int):Int = {
            a + b
        }

        // 1. 考虑固定一个加数的场景
        def addByFour(b:Int):Int={
            4 + b
        }

        // 2. 当固定加数改变时，扩展将固定加数作为参数传入，但是是作为"第一层参数"传入
        def addByA(a:Int): Int => Int = {
            def addB(b:Int):Int = {
                a + b  // 闭包
            }
            addB
        }

        // 闭包采用柯里化的方式来写
        def addCurrying(a:Int)(b:Int):Int={
            a + b
        }

        println(addCurrying(10)(20))
    }
}
```



## 惰性函数

```scala
package com.stanlong.scala

/**
 * 惰性函数
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        lazy val result = sum(10,20) // 这段使用了lazy， 函数中的println("测试懒加载")并不会执行
        println("----------------")
        println("result = " + result) // 只有在函数调用的时候， 函数中的println("测试懒加载")才会执行
    }
    // args:Int* 可变形参，可变形参得是最后一个参数
    def sum(num1:Int, args:Int*):Int ={
        println("测试懒加载")
        var sum = num1;
        for(item <- args){
            sum = sum + item
        }
        sum
    }
}
```

# 高级编程



### 偏函数

```scala
package com.stanlong.scala

/**
 * 偏函数
 * 将包在大括号内的一组case语句封装为函数，我们称之为偏函数，它只对会作用于指定类型的参数或指定范围值的参数实施计算，
 * 超出范围的值会忽略（未必会忽略，这取决于你打算怎样处理）
 *
 * 入门案例
 * 已知集合val list = List(1, 2, 3, 4, "abc") ，请完成如下要求:
 * 将集合list中的所有数字+1，并返回一个新的集合
 * 要求忽略掉 非数字 的元素，即返回的 新的集合 形式为 (2, 3, 4, 5)
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        val list = List(1, 2, 3, 4, "abc")

        // 思路一 filter + map 方式解决
        println(list.filter(f1).map(f2).map(f3))

        // 思路二，使用偏函数解决
        // PartialFunction[Any, Int] 表示偏函数接受的类型是Any， 返回的类型是Int
        // isDefinedAt 如果返回true， 就会去调用apply构建对象实例。如果是false，则过滤
        // apply 构造器， 对传入的值加一， 并返回新的集合
        val partialFun =  new PartialFunction[Any, Int] {
            override def isDefinedAt(x: Any): Boolean = x.isInstanceOf[Int]

            override def apply(v1: Any): Int = {
                v1.asInstanceOf[Int] + 1
            }
        }
        // 使用偏函数
        println(list.collect(partialFun))

        // 使用构建特质的实现类(使用的方式是PartialFunction的匿名子类)
        // PartialFunction 是个特质(看源码)
        // 构建偏函数时，参数形式   [Any, Int]是泛型，第一个表示参数类型，第二个表示返回参数
        //当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行isDefinedAt()如果为true ,就会执行 apply, 构建一个新的Int 对象返回
        //执行isDefinedAt() 为false 就过滤掉这个元素，即不构建新的Int对象.
        //map函数不支持偏函数，因为map底层的机制就是所有循环遍历，无法过滤处理原来集合的元素
        //collect函数支持偏函数

        // 偏函数简化形式
        // 1.简化形式一
        val list1 = list.collect(f4)
        println(list1)

        // 2.简化形式二
        val list2 = list.collect{ case i: Int => i + 1 }
        println(list2)
    }

    def f1(n:Any):Boolean={
        n.isInstanceOf[Int]
    }
    def f2(n:Any):Int={
        n.asInstanceOf[Int]
    }
    def f3(n:Int):Int={
        n + 1
    }

    def f4: PartialFunction[Any, Int] = {
        case i: Int => i + 1 // case语句可以自动转换为偏函数
    }
}
```

### 作为参数的函数

```scala
package com.stanlong.scala

/**
 * 函数作为参数
 * 函数作为一个变量传入到了另一个函数中，那么该作为参数的函数的类型是：function1，即：(参数类型) => 返回类型
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        //说明
        val result1 = Array(1, 2, 3, 4).map(plus(_))
        println(result1.mkString(","))

        println("plus的函数类型function1" + (plus _))

        // map(plus(_)) 中的plus(_) 就是将plus这个函数当做一个参数传给了map，_这里代表从集合中遍历出来的一个元素。
        //
        //plus(_) 这里也可以写成 plus 表示对 Array(1,2,3,4) 遍历，将每次遍历的元素传给plus的 x
        //进行 3 + x 运算后，返回新的Int ，并加入到新的集合 result1中
        //def map[B, That](f: A => B) 的声明中的 f: A => B 一个函数

    }
    def plus(x: Int) = 3 + x
}
```

### 参数类型推断

```scala
package com.stanlong.scala

/**
 * 参数推断省去类型信息（在某些情况下[需要有应用场景]，参数类型是可以推断出来的，如list=(1,2,3) list.map()
 * map中函数参数类型是可以推断的)，同时也可以进行相应的简写
 *
 * 参数类型推断写法说明
 *
 * 参数类型是可以推断时，可以省略参数类型
 * 当传入的函数，只有单个参数时，可以省去括号
 * 如果变量只在=>右边只出现一次，可以用_来代替
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val list = List(1, 2, 3, 4)
        println(list.map((x:Int)=>x + 1)) //(2,3,4,5)
        println(list.map((x)=>x + 1))
        println(list.map(x=>x + 1))
        println(list.map(_ + 1))


        // map是一个高阶函数，因此也可以直接传入一个匿名函数，完成map
        //当遍历list时，参数类型是可以推断出来的，可以省略数据类型Intprintln(list.map((x)=>x + 1))
        //当传入的函数，只有单个参数时，可以省去括号println(list.map(x=>x + 1))
        //如果变量只在=>右边只出现一次，可以用_来代替println(list.map(_ + 1))
        println(list.reduce(f1))
        println(list.reduce((n1:Int, n2:Int) => n1 + n2))
        println(list.reduce((n1, n2) => n1 + n2)) // list 里n1和n2的类型可以推断出来，所以类型省略了
        println(list.reduce(_ + _)) //n1 和 n2 只出现了一次，也可以省略

    }

    def f1(n1:Int, n2:Int) :Int={
        n1 + n2
    }
}
```

### 闭包

```scala
package com.stanlong.scala

/**
 * 闭包
 * 闭包就是一个函数和与其相关的引用环境组合的一个整体(实体)
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        //1.用等价理解方式改写 2.对象属性理解
        def minusxy(x: Int) = (y: Int) => x - y
        //f函数就是闭包.
        val f = minusxy(20)
        println("f(1)=" + f(1)) // 19
        println("f(2)=" + f(2)) // 18

        //第1点
        //(y: Int) => x – y
        //
        //返回的是一个匿名函数 ，因为该函数引用到到函数外的 x,那么  该函数和x整体形成一个闭包
        //如：这里 val f = minusxy(20) 的f函数就是闭包
        //
        //你可以这样理解，返回函数是一个对象，而x就是该对象的一个字段，他们共同形成一个闭包
        //当多次调用f时（可以理解多次调用闭包），发现使用的是同一个x, 所以x不变。
        //在使用闭包时，主要搞清楚返回函数引用了函数外的哪些变量，因为他们会组合成一个整体(实体),形成一个闭包
    }
}
```

```scala
package com.stanlong.scala

/**
 * 闭包
 * 请编写一个程序，具体要求如下
 * 编写一个函数 makeSuffix(suffix: String)  可以接收一个文件后缀名(比如.jpg)，并返回一个闭包
 * 调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀(比如.jpg) ,则返回 文件名.jpg , 如果已经有.jpg后缀，则返回原文件名。
 * 要求使用闭包的方式完成
 * String.endsWith(xx)
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {

        val f = makeSuffix(".jpg")
        println(f("dog"))
        println(f("cat"))
        println(f("monster.jpg"))

        // 返回的函数和 makeSuffix (suffix: String) 的 suffix 变量 和返回的函数组合成一个闭包,
        // 因为 返回的函数引用到suffix这个变量
        //我们体会一下这个闭包的好处，如果使用传统的方法，也可以轻松实现这个功能，但是传统方法需要每次都传入 后缀名，比如 .jpg ,
        // 而闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复使用。大家可以仔细的体会一把！
    }

    def makeSuffix(suffix: String) = (name: String) => {
        if (name.endsWith(suffix) == false) {
            name + suffix
        }else {
            name
        }
    }
}
```

### 函数柯里化

```scala
package com.stanlong.scala

/**
 * 柯里化
 * 函数编程中，接受多个参数的函数都可以转化为接受单个参数的函数，这个转化过程就叫柯里化
 *
 * 编写一个函数，接收两个整数，可以返回两个数的乘积，要求:
 *
 * 使用常规的方式完成
 * 使用闭包的方式完成
 * 使用函数柯里化完成
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        def mul(x: Int, y: Int) = x * y
        println(mul(10, 10))

        def mulCurry(x: Int) = (y: Int) => x * y
        println(mulCurry(10)(9))

        def mulCurry2(x: Int)(y:Int) = x * y
        println(mulCurry2(10)(8))

    }
}
```

```scala
package com.stanlong.scala

/**
 * 柯里化
 * 最佳实践
 * 比较两个字符串在忽略大小写的情况下是否相等，注意，这里是两个任务：
 * 全部转大写（或小写）
 * 比较是否相等
 */
object Exercise01 {
    def main(args: Array[String]): Unit = {
        val s1 = "aaBcn"
        val s2 = "aabcN"

        println(checkEq(s1,s2))

        //使用柯里化，可以化的要求是: 接受多个参数的函数都可以转化为接受单个参数的函数

        //柯里化这个题的思路
        //1. 给String的功能进行扩展(隐式类)
        //2. 编写一个checkEq( ss : String )( f: (String, String)=> Boolean )的方法
        //3. 比如: s.checkEq(ss: String)//接收一个参数，完成将s 和 ss转成大写/或小写的
        //4. f: (String, String)=> Boolean 函数完成比较功能

        val str1 = "aaBcn"
        val str2 = "aabcN"
        //调用方式1
        println(str1.checkEq(str2)(eq)) //在checkEq内部调用eq返回true or false
        println(str1.checkEq(str2)((x:String, y:String) => x.equals(y))) //直接写匿名函数作为第二个参数值
        //上面的简化写法
        println(str1.checkEq(str2)((x, y) => x.equals(y)))
        //继续简化【因为x,y在 => 右边只出现过一次，因此可以去掉括号，使用 _】
        println("-----------------------------")
        println(str1.checkEq(str2)(_.equals(_)))

    }

    //常规方法
    def checkEq(s1: String, s2: String) = {
        //1.先将其全部转成大写(或小写)
        val s11 = s1.toLowerCase
        val s22 = s2.toLowerCase
        //2.比较是否相等
        s11.equals(s22)
    }

    def eq( s1 : String, s2 : String ): Boolean = {
        s1.equals(s2)
    }

    // 隐式类
    implicit class TestEq( s : String ) {
        def checkEq(ss: String)(f: (String, String) => Boolean): Boolean = {
            // 把字符串变成小写
            f(s.toLowerCase, ss.toLowerCase)
        }
    }
}
```

### 抽象控制

```scala
package com.stanlong.scala

/**
 * 抽象控制
 *
 * 抽象控制函数，满足如下条件
 * 参数是函数
 * 函数参数没有输入值也没有返回值
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        //说明
        //1.myRunInThread {} 本身是 myRunInThread() 为了习惯 写成了 myRunInThread {}
        //2.() => 后面的三句话是一个整体，你也可以使用{} 括起来.
        //3.() => xxxx 就是一个匿名函数，传递给 f1
        myRunInThread {
            () => println("干活咯！5秒完成...")
                Thread.sleep(5000)
                println("干完咯！")
        }

    }
    //说明
    //1. myRunInThread 是一个高阶函数
    //2. 接收的函数式 () => Unit 即 没有参数，没有返回值
    def myRunInThread(f1: () => Unit): Unit = {
        new Thread {
            //重写了 Thread 的 run 方法,这里调用了f1函数.
            override def run(): Unit = {
                f1()
            }
        }.start()
    }
}
```

```scala
package com.stanlong.scala

/**
 * 抽象控制
 *
 * 进阶用法：实现类似while的until函数
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        //说明
        //1. 只要condition 为真，就不在执行 block代码
        def until(condition: => Boolean)(block: => Unit) {//类似while循环，递归
            if (!condition) {
                block // block就是【x -= 1 println(x)】，会导致x的减小
                //这里传入的始终是 () => {x == 0} 的匿名函数，但是x是变化,因此总会x==0成立的
                until(condition)(block)
            }
        }

        var x = 10
        until(x == 0) {
            x -= 1
            println(x)
        }
    }
}
```

## 递归编程

```scala
package com.stanlong.scala

import java.text.SimpleDateFormat
import java.util.Date

/**
 * 递归
 * 递归执行时间和普通执行时间相差不大
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={

        // 应用实例要求:
        //计算1-50的和
        // 常规的解决方式
        val now: Date = new Date()
        val dateFormat: SimpleDateFormat =
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")
        val date = dateFormat.format(now)
        println("运行开始时间：" + date) //输出时间
        var res = BigInt(0)
        var num = BigInt(1)
        var maxVal = BigInt(99999999l) //BigInt(99999999l)[测试效率大数]
        while (num <= maxVal) {
            res += num
            num += 1
        }
        println("res=" + res)
        val now2: Date = new Date()
        val date2 = dateFormat.format(now2)
        println("运行结束时间：" + date2) //输出时间



        //测试
        var num1 = BigInt(1)
        var sum1 = BigInt(0)
        val now3: Date = new Date()
        val date3 = dateFormat.format(now3)
        println("递归执行开始时间：" + date3) //输出时间
        var res1 = mx(num1,sum1)
        val now4: Date = new Date()
        val date4 = dateFormat.format(now4)
        println("res=" + res1)
        println("递归执行结束时间：" + date4) //输出时间

    }

    // 递归的方式来解决
    def mx(num:BigInt,sum:BigInt):BigInt = {
        if(num <= 99999999l) return mx(num+1,sum + num)
        else return sum
    }
}
```

```scala
package com.stanlong.scala

/**
 * 递归
 * 递归求最大值
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        println(List(1, -1, 9).max)
   }

    // 递归求最大值
    def max(xs: List[Int]): Int = {
        if (xs.isEmpty)
            throw new java.util.NoSuchElementException
        if (xs.size == 1)
            xs.head
        else if (xs.head > max(xs.tail)) xs.head else max(xs.tail)
    }

}
```

```scala
package com.stanlong.scala

/**
 * 递归
 * 递归反正字符串
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        val abc = "StanLong"
        print(reverse(abc))
    }

    // 递归反正字符串
    def reverse(xs: String): String =
        if (xs.length == 1) xs else reverse(xs.tail) + xs.head

}
```

```scala
package com.stanlong.scala

/**
 * 递归
 * 递归求阶乘
 */
object Exercise01 {
    def main(args: Array[String]): Unit ={
        println(factorial(4))
    }

    // 递归求阶乘
    def factorial(n: Int): Int =
        if (n == 0) 1 else n * factorial(n - 1)
}
```



