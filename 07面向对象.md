# 构造器











# 继承

```scala
/**
 * 继承
 */
object Exercise01 extends App { // 继承App后，就可以直接在这个类中执行代码，不需要再写main入口
    println("app~~")
}
```

```scala
package com.stanlong.scala

/**
 * 继承
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        val student = new Student
        student.name = "StanLong"
        student.age = 27
        student.studying()
        student.showInfo()
    }
}


class Person(){
    var name : String = _
    var age : Int = _

    def showInfo(): Unit = {
        println("学生信息如下")
        println("名字: " + this.name)
        println("年龄: " + this.age)
    }
}

class Student extends Person{
    def studying(): Unit = {
        println(this.name + " 学习scala...")
    }
}
```

## 方法重写

```scala
package com.stanlong.scala

/**
 * 方法重写
 */
object Exercise01{ // 继承App后，就可以直接在这个类中执行代码，不需要再写main入口
    def main(args: Array[String]): Unit = {
        val student = new Student
        student.name = "StanLong"
        student.age = 27
        student.studying()
        student.showInfo()
    }
}


class Person(){
    var name : String = _
    var age : Int = _

    def showInfo(): Unit = {
        println("学生信息如下")
        println("名字: " + this.name)
        println("年龄: " + this.age)
    }
}

class Student extends Person{
    def studying(): Unit = {
        println(this.name + " 学习scala...")
    }

    // 需要显示的使用 override 关键字
    override def showInfo(): Unit = {
        println("方法重写")
        super.showInfo()
    }
}
```

# 多态

```scala
package com.stanlong.scala

/**
 * 多态
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        var student = new Student
        var person = new Person
        println(classOf[Student]) // 获取对象中的类型
        println(student.getClass.getName) // Java中用反射的方式得到类型

        person = student // 将子类引用给父类（向上转型）

        var p = person.asInstanceOf[Student] // 将父类引用重新转换成子类引用，向下转型
        p.studying()

    }
}


class Person(){
    var name : String = _
    var age : Int = _

    def showInfo(): Unit = {
        println("学生信息如下")
        println("名字: " + this.name)
        println("年龄: " + this.age)
    }
}

class Student extends Person{
    def studying(): Unit = {
        println(this.name + " 学习scala...")
    }
}
```

代码实践

```scala
package com.stanlong.scala

/**
 * 多态
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        val student = new Student
        val emp = new Emp
        test(student)
        test(emp)
    }

    def test(person: Person):Unit = {
        if (person.isInstanceOf[Student]){
            person.asInstanceOf[Student].studying()
        }else if(person.isInstanceOf[Emp]){
            person.asInstanceOf[Emp].working()
        }else{
            println("不知道是啥类型")
        }
    }
}


class Person(){
    var name : String = _
    var age : Int = _

    def showInfo(): Unit = {
        println("学生信息如下")
        println("名字: " + this.name)
        println("年龄: " + this.age)
    }
}

class Student extends Person{
    def studying(): Unit = {
        println("学习scala...")
    }
}

class Emp extends Person{
    def working(): Unit = {
        println("用scala搬砖...")
    }
}
```

# 超类构造分析

```scala
package com.stanlong.scala

/**
 * 超类构造分析
 * 先构建父类主构造器，再构建子类主构造器，再构建父类辅助构造器，再构建子类辅助构造器
 * 只有主构造器可以调用父类的构造器。辅助构造器不能直接调用父类的构造器。
 * 
 */
object Exercise01{
    def main(args: Array[String]): Unit = {
        // val student = new Student()
        // 输出结果
        // Person...
        // Emp...

        val student2 = new Student("沈万三")
        // 输出结果
        // Person...
        // Emp...
        // Student 辅助构造器
    }
}


class Person(){
    var name = "StanLong"
    println("Person...")
}

class Student extends Person{
    println("Emp...")

    def this(name:String){
        this // 必须调用主构造器
        this.name = name
        println("Student 辅助构造器")
    }
}
```







